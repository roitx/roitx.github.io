<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8">
    <title>Ultra Glassy Hex-Shatter</title>
    <style>
        body { margin: 0; background: #050505; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Segoe UI', sans-serif; }
        #timer-ui { position: absolute; top: 20px; color: #0ff; font-size: 30px; letter-spacing: 5px; text-shadow: 0 0 15px #0ff; font-weight: bold; }
        canvas { border-radius: 20px; box-shadow: 0 0 50px rgba(0, 255, 255, 0.1); }
    </style>
</head>
<body>
    <div id="timer-ui">SYSTEM STABLE: <span id="clock">15.0</span></div>
    <canvas id="world"></canvas>

<script>
const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
const clock = document.getElementById('clock');

canvas.width = window.innerWidth * 0.8;
canvas.height = window.innerHeight * 0.8;

let entities = [];
let fragments = [];
let start = Date.now();
const limit = 15000;

class Hexagon {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.size = 20 + Math.random() * 20;
        this.v = { x: (Math.random()-0.5)*6, y: (Math.random()-0.5)*6 };
        this.hue = Math.random() * 360;
        this.angle = 0;
        this.rotSpeed = (Math.random()-0.5)*0.1;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            ctx.lineTo(this.size * Math.cos(i * Math.PI / 3), this.size * Math.sin(i * Math.PI / 3));
        }
        ctx.closePath();
        ctx.strokeStyle = `hsla(${this.hue}, 100%, 50%, 0.8)`;
        ctx.lineWidth = 3;
        ctx.stroke();
        // Inner Glow
        ctx.fillStyle = `hsla(${this.hue}, 100%, 50%, 0.1)`;
        ctx.fill();
        ctx.restore();
    }

    update(isCollapse) {
        this.x += this.v.x;
        this.y += this.v.y;
        this.angle += this.rotSpeed;

        // Bounce from walls
        if(this.x < 0 || this.x > canvas.width) {
            this.v.x *= -1;
            if(isCollapse) this.shatter();
        }
        if(this.y < 0 || this.y > canvas.height) {
            this.v.y *= -1;
            if(isCollapse) this.shatter();
        }
    }

    shatter() {
        for(let i=0; i<6; i++) {
            fragments.push(new Fragment(this.x, this.y, this.hue));
        }
        this.dead = true;
    }
}

class Fragment {
    constructor(x, y, hue) {
        this.x = x; this.y = y;
        this.v = { x: (Math.random()-0.5)*12, y: (Math.random()-0.5)*12 };
        this.life = 1.0;
        this.hue = hue;
    }
    update() {
        this.x += this.v.x; this.y += this.v.y;
        this.v.y += 0.2; // Gravity for fragments
        this.life -= 0.02;
    }
    draw() {
        ctx.fillStyle = `hsla(${this.hue}, 100%, 50%, ${this.life})`;
        ctx.fillRect(this.x, this.y, 4, 4);
    }
}

// Initial Spawn
for(let i=0; i<15; i++) entities.push(new Hexagon(Math.random()*canvas.width, Math.random()*canvas.height));

function animate() {
    // Glassy Trail Effect
    ctx.fillStyle = 'rgba(5, 5, 5, 0.2)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const now = Date.now();
    const elapsed = now - start;
    const isCollapse = elapsed > limit;
    const rem = Math.max(0, (limit - elapsed)/1000);
    
    clock.innerText = rem.toFixed(1);
    if(isCollapse) {
        document.getElementById('timer-ui').innerText = "SYSTEM COLLAPSE!";
        document.getElementById('timer-ui').style.color = "#f00";
    }

    entities.forEach((h, i) => {
        h.update(isCollapse);
        h.draw();
        if(h.dead) entities.splice(i, 1);
    });

    fragments.forEach((f, i) => {
        f.update();
        f.draw();
        if(f.life <= 0) fragments.splice(i, 1);
    });

    // Interaction Line (Connect hexes if close)
    if(!isCollapse) {
        for(let i=0; i<entities.length; i++) {
            for(let j=i+1; j<entities.length; j++) {
                let dx = entities[i].x - entities[j].x;
                let dy = entities[i].y - entities[j].y;
                let d = Math.sqrt(dx*dx + dy*dy);
                if(d < 150) {
                    ctx.strokeStyle = `rgba(0, 255, 255, ${1 - d/150})`;
                    ctx.beginPath();
                    ctx.moveTo(entities[i].x, entities[i].y);
                    ctx.lineTo(entities[j].x, entities[j].y);
                    ctx.stroke();
                }
            }
        }
    }

    if(entities.length > 0 || fragments.length > 0) requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
