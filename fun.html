<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bouncing Ball Multiplier</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; justify-content: center; align-items: center; height: 100vh; }
        canvas { border: 1px solid #333; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = 600;
canvas.height = 800;

const gravity = 0.25;
const friction = 0.98; // Keeps balls from bouncing forever
const rings = [
    { radius: 100, multiplier: 7, color: '#ffff00', label: 'x7' },
    { radius: 150, multiplier: 5, color: '#a020f0', label: 'x5' },
    { radius: 200, multiplier: 3, color: '#00ff00', label: 'x3' },
    { radius: 250, multiplier: 1, color: '#ff0000', label: 'x1' }
];

class Ball {
    constructor(x, y, vx, vy, radius, color) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.radius = radius;
        this.color = color;
    }

    draw() {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
    }

    update() {
        this.vy += gravity;
        this.x += this.vx;
        this.y += this.vy;

        // Check collision with each ring
        rings.forEach(ring => {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const dx = this.x - centerX;
            const dy = this.y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // If ball hits the ring boundary
            if (Math.abs(distance - ring.radius) < this.radius) {
                // Simple bounce logic: reflect velocity
                const normalX = dx / distance;
                const normalY = dy / distance;
                
                const dot = this.vx * normalX + this.vy * normalY;
                this.vx = (this.vx - 2 * dot * normalX) * friction;
                this.vy = (this.vy - 2 * dot * normalY) * friction;
                
                // Prevent sticking
                this.x = centerX + normalX * (ring.radius - this.radius);
                this.y = centerY + normalY * (ring.radius - this.radius);
            }
        });

        this.draw();
    }
}

let balls = [new Ball(300, 300, 2, 0, 8, 'orange')];

function drawUI() {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    rings.forEach(ring => {
        // Draw the ring arc
        ctx.beginPath();
        ctx.arc(cx, cy, ring.radius, 0, Math.PI * 2);
        ctx.stroke();

        // Draw Multiplier Circle at bottom
        ctx.beginPath();
        ctx.arc(cx, cy + ring.radius, 15, 0, Math.PI * 2);
        ctx.fillStyle = ring.color;
        ctx.fill();
        ctx.fillStyle = 'black';
        ctx.font = 'bold 12px Arial';
        ctx.fillText(ring.label, cx, cy + ring.radius);
    });
}

function animate() {
    // Semi-transparent clear for motion trail effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawUI();

    balls.forEach((ball, index) => {
        ball.update();
        
        // Remove balls that fly off screen
        if (ball.y > canvas.height) {
            balls.splice(index, 1);
        }
    });

    // Keep at least one ball alive for demo
    if (balls.length === 0) {
        balls.push(new Ball(300, 250, Math.random() * 4 - 2, 0, 8, 'orange'));
    }

    requestAnimationFrame(animate);
}

animate();
</script>
</body>
</html>
